---
layout: post
categories: datamining
title: SAC思想探索
---

在数据分析中，基本一半的时间都是在对原始数据进行清洗，提取，分层等相关的预处理工作。所以快速有效的对数据进行预处理，对于时间的节省，效率的提升都能起到事半功倍的效果。

上一期专栏最后给大家留了一个小问题

<pre>
#    id       date      value
# 1: 27 2014-01-09 0.20597457
# 2: 27 2014-01-26 0.62911404
# 3: 27 2014-02-07 0.68702285
# 4: 37 2014-02-06 0.17655675
# 5: 37 2014-02-09 0.06178627
# 6: 37 2014-02-13 0.38410372
</pre>


有两个ID，三个日期。先算出来对于每个ID，在最靠近的两个日期中，value的平均值。

问题其实不算复杂，其实懂得其中的原理之后可以触类旁通。

在进入更加技术化的细节之前，先介绍下有关数据分析特别有名“S-A-C”思想。

在今后的所有类似的数据处理问题中，我们都会反复提到这个思想，并反复运用。

有关S-A-C思想

是指R界的大牛Hadley在他发表的文章 

[The Split-Apply-Combine Strategy for Data Analysis](http://www.jstatsoft.org/v40/i01)

这篇文章主要介绍了如何将数据进行分层（split）-应用（Apply）-结合（Combine）的思想。

稍微对R有点点了解的都应该知道Hadley，他可以说是创造了R数据分析到可视化的一个生态系统，写过的拓展包包括非常有名的plyr，dplyr，ggplot2，reshape2，lubridate，devtools，ggvis等等。

上面我所提的文章就是他介绍S-A-C的思想的经典论文，实现方法是用他自己写的plyr完成的。

不想看原文的，我这里通俗简单给大家介绍下文章的中心思想。

其实这里有两张图可以很好的说明这一切

![](/assets/images/sac/sac-1.png)
![](/assets/images/sac/sac-2.png)

其实也应该也是大家在平时数据分析中经常用到的。
我们看到原数据首先对年龄进行分层，然后进行统计，然后进行加总。

其实很简单，但这个就是SAC思想。

但是实际应用起来可以非常复杂，

因为在Apply这一个层面，可以是非常简单的简单计数统计，可以是求平均值等等描述性分析，也可以是回归，自己定义任意函数等等。

所以以后我们遇到数据分析相关问题的时候，要时刻牢记SAC思想。

这个思想也为我们的数据分析提供了更加清晰的思路和框架。

我之前写过一个简单的plyr拓展包和相关思想的博客，大家可以去看下，算是当作补充阅读了。

[http://yangchao.me/2013/03/plyr-dataming]()

[http://yangchao.me/2013/06/plyr-advanced]()

好，回到专栏开头的引例

<pre>
#    id       date      value
# 1: 27 2014-01-09 0.20597457
# 2: 27 2014-01-26 0.62911404
# 3: 27 2014-02-07 0.68702285
# 4: 37 2014-02-06 0.17655675
# 5: 37 2014-02-09 0.06178627
# 6: 37 2014-02-13 0.38410372
</pre>

数据字段其实并不多，要处理的也非常简单。

首先我们利用SAC思想进行分析。

题目要求为： 有两个ID，三个日期。先算出来对于每个ID，在最靠近的两个日期中，value的平均值。

**分层：Split**

因为我要计算每一个id对应的一个平均值，所以分层的第一类显然是ID

**计算： Apply**

对应每一个ID，我要计算一个平均值。不管中间的描述有多复杂，我们最后要得到的只是一个平均值。所以这个就是Apply的核心内容。

**整合： Combine**

就是把所有的ID和对应的平均值合并到一起。这一部可以说是最简单的。

上面就是分析的思路，可以看出不管出现什么样的问题，只要按照这个套路就都能把问题逐一细化。也更加有方向。

关于实现方法，可以说各个统计软件各个方法。

我在专栏的导读已经提到了，我更多的使用data.table这个拓展包。

有关选择data.table的原因在导读部分已经介绍的比较详尽了。

比如这个问题。

我们用data.table的解决代码

首先构造模拟的数据集。大家把我下面这段代码复制粘贴再运行就好，不必纠结具体什么意思。

{% highlight r %}
require(data.table)
set.seed(1)
sample_frame = data.frame("id" = rep(sample(1:100,2,replace=F),3),
                          "date" = sample(seq(as.Date("2014-01-01"),
                                              as.Date("2014-02-13"),by=1),6),
                          "value" = runif(6))

DT <- data.table(sample_frame, key = "id,date")
{% endhighlight %}

上面的过程是构造模拟数据

{% highlight r %}
require(data.table)
DT[, mean(tail(value, 2)), by = id]
{% endhighlight %}

整个分析过程代码只有一行。
大致的代码的解释：

`by = id`: 就是分层(Split)这一步

`mean(tail(value, 2))`: 为计算（Apply）这一步。mean()这个函数指的是求平均值，tail()函数意思为在value这一列中，取倒数两个。即为tail(value,2)

所以就是这样。

有关data.table

希望大家还是多看看官方住的帮助文档。

我在接下来的专栏中还会反复的提到和用到。

下一篇也会更加深入的讲解这个拓展包的用法。









